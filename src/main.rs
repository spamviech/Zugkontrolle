//! Steuerung einer Model-Eisenbahn Ã¼ber einen raspberry pi

use std::marker::PhantomData;

use gio::prelude::*;
use gtk::prelude::*;
use gtk::{Application, ApplicationWindow, DrawingArea};
use simple_logger::SimpleLogger;

use gleis::gerade::Gerade;
use gleis::types::*;
use gleis::widget::Zeichnen;

pub mod gleis;
pub mod zugtyp;

// include std in doc generated by `cargo doc`
// https://github.com/rust-lang/rfcs/issues/2324#issuecomment-502437904
#[cfg(doc)]
#[doc(inline)]
pub use std;

#[cfg(feature = "derive")]
pub use zugkontrolle_derive::AnchorLookup;

fn main() {
    SimpleLogger::new().init().expect("failed to initialize error logging");

    let application =
        Application::new(None, Default::default()).expect("failed to initialize GTK application");

    application.connect_activate(|app| {
        let window = ApplicationWindow::new(app);
        window.set_title("Zugkontrolle");
        window.set_default_size(600, 400);

        let drawing_area = DrawingArea::new();
        fn test(_drawing_area: &DrawingArea, c: &cairo::Context) -> glib::signal::Inhibit {
            let cairo: &Cairo = &Cairo::new(c);
            let gerade: Gerade<zugtyp::Maerklin> =
                Gerade { length: Length(180.), zugtyp: PhantomData };
            cairo.translate(
                CanvasX((400 - gerade.width()) as f64),
                CanvasY((200 - gerade.height()) as f64),
            );
            gerade.zeichne(cairo);
            cairo.stroke();
            glib::signal::Inhibit(false)
        }
        drawing_area.set_size_request(600, 400);
        drawing_area.connect_draw(test);
        window.add(&drawing_area);

        window.show_all();
    });

    application.run(&[]);
}
