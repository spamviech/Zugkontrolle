Laden dauert teilweise sehr lange

Beim Wegstrecke hinzufügen skaliert der Seiteninhalt nicht.
    Vermutlich ein Problem mit Assistant

Anzeige sprachabhängig, ohne Show-Instanz
    über eigene Anzeige-Klasse
        Done
    speichern der aktuellen Sprache im Zustand
        Kommandozeilen-Argument bezieht sich nur noch auf Anfangs-Sprache
            Speichern in .json?
            Wird nicht gespeichert
        Sprachwechsel im Cmd-UI kein Problem:
            wird sowieso neu erzeugt
            muss noch implementiert werden
                Done
        GTK-Objekte müssen bei Sprachwechsel neu benannt werden
            ergänze (SP ObjektGui) im Zustand um [Sprache -> IO ()]
                werden bei Sprachwechsel alle via sequence_ aufgerufen
                wie wird die IO-Funktion wieder gelöscht?
                    ToDo!!!
                    Widgets werden nicht gelöscht -> IO-Aktion muss auch nicht gelöscht werden
                    führt evtl. zu Memory-Leaks, wenn das Programm zu lange läuft
                Mit Objekt als Widget taggen? [(Gtk.Widget, Sprache -> IO ())]
                    Map/HashMap wegen fehlender Ord/Hashable-Instanz nicht möglich
                Speichere (Maybe [Sprache -> IO ()]) in TVar, welche bei löschen auf Nothing gesetzt wird
                    Übergebe Maybe (TVar (Maybe [Sprache -> IO ()])) an verwendeSpracheGui
                    Wenn Nothing, speichere weiterhin global
                    Wenn TVar, schaue Inhalt an
                        Wenn Nothing füge ausführen aller TVar-Aktionen zur globalen Liste hinzu
                            und ersetzte TVar-Inhalt durch Just [übergebeneAktion]
                        Wenn (Just ..) füge nur die übergebene Aktion zur TVar hinzu
                Speichere Aktionen in SpracheGui als [Either (Sprache -> IO ()) (TVar (Maybe [Sprache -> IO ()]))]
                    Wenn bei Aufruf (via foldM) TVar mit Nothing entdeckt wird, lösche diesen Eintrag
                    Ist ein widgetDestroy notwendig?
                Führe außerdem widgetDestroy beim entfernen aus
                    jeweils äußerstes Widget (welches bisher nur aus Container entfernt wird) sollte ausreichen
            Sprachwechsel über AuswahlWidget (ComboBox)
                Done

Haddock schlägt an Language.hs fehl
    Sonderzeichen im Namen bei fehlender Dokumentation führt zu Absturz von Haddock
    Probieren ob ein-Datei-Version funktioniert
        Funktioniert, aber jetzt stürzt Haddock nach Zug.UI.Save ab
    Kompilationsreihenfolge:
        [ 1 of 41] Compiling Paths_Zugkontrolle
        [ 2 of 41] Compiling Zug.Anbindung.I2C
        [ 3 of 41] Compiling Zug.Language.Operatoren
        [ 4 of 41] Compiling Zug.Language
        [ 5 of 41] Compiling Zug.Enums
        [ 6 of 41] Compiling Zug.Anbindung.Wartezeit
        [ 7 of 41] Compiling Zug.Anbindung.PCF8574
        [ 8 of 41] Compiling Zug.Anbindung.Anschluss
        [ 9 of 41] Compiling Zug.Anbindung.SoftwarePWM
        [10 of 41] Compiling Zug.Language.TemplateHaskell
        [11 of 41] Compiling Zug.Menge
        [12 of 41] Compiling Zug.Options
        [13 of 41] Compiling Zug.Anbindung
        [14 of 41] Compiling Zug.Plan
        [15 of 41] Compiling Zug.Objekt
        [16 of 41] Compiling Zug.UI.Base
        [17 of 41] Compiling Zug.UI.Cmd.Lexer
        [18 of 41] Compiling Zug.UI.Cmd.Parser.Anfrage
        [19 of 41] Compiling Zug.UI.Gtk.Klassen.TemplateHaskell
        [20 of 41] Compiling Zug.UI.Gtk.Klassen
        [21 of 41] Compiling Zug.UI.Gtk.SpracheGui
        [22 of 41] Compiling Zug.UI.Gtk.Hilfsfunktionen
        [23 of 41] Compiling Zug.UI.Gtk.ScrollbaresWidget
        [24 of 41] Compiling Zug.UI.Gtk.FortfahrenWennToggled
        [25 of 41] Compiling Zug.UI.Gtk.Auswahl
        [26 of 41] Compiling Zug.UI.Gtk.Fliessend
        [27 of 41] Compiling Zug.UI.Gtk.Anschluss
        [28 of 41] Compiling Zug.UI.Gtk.ZugtypSpezifisch
        [29 of 41] Compiling Zug.UI.Save
        [30 of 41] Compiling Zug.UI.Befehl
        [31 of 41] Compiling Zug.UI.StatusVar
        [32 of 41] Compiling Zug.UI.Gtk.StreckenObjekt
        [33 of 41] Compiling Zug.UI.Gtk.Assistant
        [34 of 41] Compiling Zug.Warteschlange
        [35 of 41] Compiling Zug.UI.Gtk.Fenster
        [36 of 41] Compiling Zug.UI.Gtk
        [37 of 41] Compiling Zug.UI.Cmd.Parser.Plan
        [38 of 41] Compiling Zug.UI.Cmd.Parser.StreckenObjekt
        [39 of 41] Compiling Zug.UI.Cmd.Parser
        [40 of 41] Compiling Zug.UI.Cmd
        [41 of 41] Compiling Zug.UI

Jedem Plan eine eigene ProgressBar spendieren.
    Aktuell kommt es zu RaceConditions in der Anzeige wenn mehrere gleichzeitig ausgeführt werden.

Laden einer Liste schlägt momentan für gesamte Liste fehl
    Elementweise überprüfen und nur fehlgeschlagene ignorieren
    Nach Laden Liste mit fehlgeschlagenen Elementen anzeigen
    Nicht für Wegstrecken-Element-Listen verwenden!

Erlaube "Warten auf Signal"
    Ergänze "Warten"-Funktion von Plänen auf ein Signal (Pin-Input = HIGH/LOW) zu warten.
    Zeit-basierte Lösung wird weiterhin unterstützt.
    Mögliche Realisierung über Kontaktschienen (Ground-Kontakt durch Zug verbunden).

Code-Stil vereinheitlichen:
    hlint berücksichtigen(?)
    Konstruktoren nur wenn notwendig in Klammern setzten
    Argumente von Typkonstruktoren eingerückt, jeweils in neuer Zeile
    Funktionen ohne Pattern match (nur ein Variablen-Pattern) ohne extra Leerzeichen
    Alle (auch eigene) Module mit Import-Liste
    Namen auf Deutsch
    Verwendung der Spracherweiterungen
        ScopedTypeVariables
            explizites `forall a.` in Deklaration bindet a als festen Typ für die gesamte Funktion (auch let/where-Deklarationen)
            erlaubt vorher teilweise unmögliche Typ-Deklarationen (z.B. res :: a in einem where-Binding als Rückgabewert der Funktion verwendbar)
        OverlappableInstances
            {-# Overlappable #-}/{-# Overlapping #-} bei Instanz-Deklaration
            allgemeinen Fall abdeckbar, ohne Spezial-Instanzen zu verhindern
            Benötigt Spracherweiterungen FlexibleInstances, UndecidableInstances, MonoLocalBinds (?)
            Done
    etc.


Allgemeines Anschluss-Objekt mit allen möglichen Funktionen erstellen?
    Strom an/aus
        permanent
        auf Zeit
    PWM

gi-gtk/gi-gtk-declarative verwenden?
    gi-gtk scheint neuer und besser gewartet zu sein.
    Wirft auf Raspberry Pi bisher Fehlermeldungen.

Beispiel-Schaltpläne erstellen
    Beispiel-Schaltpläne zum Anschluss der Schiene an den Raspberry Pi erstellen.
    In der ReadMe erwähnen/verlinken.

Fix tests
    Änderungen berücksichtigen
    oder entfernen, vergesse ich sowieso ständig

Test-Suite vervollständigen
    Fehlende Tests erstellen.
    Test-Bibliothek verwenden (hspec)?
        'shouldBe' und 'shouldSatisfy'

Hilfetext von optparse-applicative übersetzten
    Eigene helper-Funktion erstellen.
    Außerdem sämtliche Hilfetexte in Language.hs auslagern.

---------------------------Gelöst--------------------------
Speichern von json in yaml konvertieren
    Packet yaml zur Konvertierung verwenden
        https://hackage.haskell.org/package/yaml
    Verwendet intern aeson, kann somit problemlos als plug-and-play replacement verwendet werden
        Done

Gtk.StreckenObjekt.hs
    ..PackNew auf MStatusGuiT umstellen
    TMVar wird dadurch nicht mehr benötigt
        es kann 'ausführenTMVarBefehl' in 'buttonLadenPack' verwendet werden
    Done

Cmd-UI:
    *Unbekannt aus Datentypen entfernen und eigenen (ParseErgebnis a)-Datentyp verwenden
        *Unbekannt hat überall identische Struktur
    Analog zu Either als Fehler-Monade
        Monade geht nicht, wegen Either-Ähnlicher Typvariable (keine anderen Typen erlaubt)
        -> eigene Verkettung-Funktion erstellen
            Done
    wähleBefehl oft mit AFFehler als Ausweich-Lösung und AFZwischenwert für jedes Ergebnis
        -> eigenen Befehl wähleFortsetzung erstellen
            Done
    Jede Auswertung von AnfrageFortsetzung hat vorherigen Zustand
        -> muss im Fehlerfall nicht gespeichert werden
            Done
    Done

Rekursion in Plan ermöglichen
    erlaubt Divide-And-Conquer beim aufbauen größerer Pläne
    potentielle Endlosschleifen
        problematisch?
        nein, da 'ausführenAbbrechen' immer möglich
        bei Anzeigen/Eq-Vergleich auf Wiederholungen prüfen!
            kann mit UI nicht erzeugt werden
            Speichern in .json ebenfalls nicht möglich
            verwende nur Name bei Plänen
                vermeidet rekursive Aufrufe
                speichern Problematisch, wenn Plan schon gelöscht
                erfordert durchsuchen anderer Pläne beim Laden
                    Parse-Reihenfolge wichtig?
        Schleife-Aktion um Dauerschleife problemlos zu ermöglichen
            Probleme bei ausführenAktion/ausführenPlan
        eigenes Feld in Plan für Dauerschleife
            endliche Wiederholungen möglich mit 2 Plänen
            dadurch kein Integer-Feld notwendig
    Done

Zugtyp-Mischformen von Wegstrecken
    Mischformen können aktuell zu potentiell unerwartetem Verhalten führen:
        Wenn als Märklin interpretiert: alle Lego-Bahngeschwindigkeiten werden auf Vorwärts gestellt
        Wenn als Lego interpretiert: alle Märklin-Bahngeschwindigkeiten drehen um
    Mögliche Lösungen:
        Smart-Constructor für Wegstrecken um (wenn nötig) einen eindeutigen Zugtyp sicherzustellen?
        wegstrecke :: Text -> [Bahngeschwindigkeit] -> [Streckenabschnitt] -> [(Weiche, Richtung)] -> [Kupplung] -> Maybe Wegstrecke
            stelle smart-Destructor zum Pattern Matching bereit
            Selector-Funktionen exportieren?
            PatternSynonyms verwenden?
                https://haskell-explained.gitlab.io/blog/posts/2019/08/27/pattern-synonyms/index.html
        Identischer View-Datentyp mit exportiertem Konstruktor?
        Alternativ Umdrehen bei unklarem Zugtyp der verwendeten Bahngeschwindigkeiten verbieten?
    Gelöst über Zugtyp-Phantomtyp (DataKinds)

PCF8574Port als alternative zu Pin erlauben
    Summentyp Anschluss
    definiert in PCF8574.hs?
    eigenes Modul verwenden (Anschluss.hs) für einfache Erweiterung?
        Done
MVar durch TVar ersetzen
    sollen sowieso immer gefüllt sein
        Done

VRCheckbutton durch abstrakten Datentyp RegistrierterCheckButton ersetzen
    FortfahrenWennToggled mit MVar ersetzten durch abstrakten Datentyp, welcher registrieren beim erstellen ausführt (... -> IO RegistrierterCheckbutton)?
        LinkedMVar benötigt dadurch Update-Aktion nicht mehr
        Konstruktor muss LinkedMVar kennen
    LinkeMVar entfernen?
        Done

Widget.hs: eigenen bool-like Datentyp für Position erstellen
    data Position = First | Last
    newtype für Padding
        Done

GTK-UI: Gleichzeitiges Anzeigen mehrerer Kategorien ermöglichen
    optional?
    VPaned/HPaned verwenden