Laden von Plänen funktioniert nicht

Bahngeschwindigkeit nur Pins (kein Anschluss) erlauben
    PWM über I2C hört sich nicht vielversprechend an

Warteschlange über Data.Sequence Implementieren?

GTK stürzt öfters ab
    Zu viele Widgets?
    Passiert vor allem auf raspi
    AssistantHinzufügen besonders anfällig
        neu schreiben?
        nachdem einziger Assistant in gesamtem Programm ist allgemeine Variante nicht notwendig
        beseitigt vermutlich nicht-skalierende Widgets

Beim Wegstrecke hinzufügen skaliert der Seiteninhalt nicht.
    Vermutlich ein Problem mit Assistant
        evtl. muss Gtk.widgetExpand/Gtk.widgetVExpand explizit gesetzt werden
    Könnte auch ein Problem mit ZugtypSpezifisch sein
    Funktioniert auf raspi!!!!
        Warum????
    Plan hinzufügen: gleiches Problem, diesmal auch auf raspi

Ändere Liste zu (Map Name a)
    newtype NameSet a = NameSet (Set (Benannt a))
        class MitName a where
            erhalteName :: a -> Text
        instance (MitName a) => Ord (Benannt a)
    newtype NameSet a = NameSet (Map Name a)
        insert :: a -> NameSet a -> Maybe a
            Rückgabe: bisheriger Wert
        remove :: a -> NameSet a -> Bool
            Rückgabe: Wert vorhanden == True
        Instanzen: Eq, Foldable, IsList, Traversable(?)
    GTK-UI:
        Plan/Wegstrecke-Aktionen können werden ebenfalls angezeigt werden
    Vermeide doppelte Einträge
    Laden einer Liste schlägt momentan für gesamte Liste fehl
        Elementweise überprüfen und nur fehlgeschlagene ignorieren
        Nach Laden Liste mit fehlgeschlagenen Elementen anzeigen
        Nicht für Wegstrecken-Element-Listen verwenden!

Haddock schlägt an Language.hs fehl
    Sonderzeichen im Namen bei fehlender Dokumentation führt zu Absturz von Haddock
    Probieren ob ein-Datei-Version funktioniert
        Funktioniert, aber jetzt stürzt Haddock nach Zug.UI.Save ab
    Kompilationsreihenfolge:
        [ 1 of 40] Compiling Paths_Zugkontrolle
        [ 2 of 40] Compiling Zug.Anbindung.I2C
        [ 3 of 40] Compiling Zug.Language
        [ 4 of 40] Compiling Zug.Enums
        [ 5 of 40] Compiling Zug.Anbindung.Wartezeit
        [ 6 of 40] Compiling Zug.Anbindung.PCF8574
        [ 7 of 40] Compiling Zug.Anbindung.Anschluss
        [ 8 of 40] Compiling Zug.Anbindung.SoftwarePWM
        [ 9 of 40] Compiling Zug.Menge
        [10 of 40] Compiling Zug.Options
        [11 of 40] Compiling Zug.Anbindung
        [12 of 40] Compiling Zug.Plan
        [13 of 40] Compiling Zug.Objekt
        [14 of 40] Compiling Zug.UI.Base
        [15 of 40] Compiling Zug.UI.Cmd.Lexer
        [16 of 40] Compiling Zug.UI.Cmd.Parser.Anfrage
        [17 of 40] Compiling Zug.UI.Gtk.Klassen.TemplateHaskell
        [18 of 40] Compiling Zug.UI.Gtk.Klassen
        [19 of 40] Compiling Zug.UI.Gtk.SpracheGui
        [20 of 40] Compiling Zug.UI.Gtk.Hilfsfunktionen
        [21 of 40] Compiling Zug.UI.Gtk.ScrollbaresWidget
        [22 of 40] Compiling Zug.UI.Gtk.FortfahrenWennToggled
        [23 of 40] Compiling Zug.UI.Gtk.Auswahl
        [24 of 40] Compiling Zug.UI.Gtk.Fliessend
        [25 of 40] Compiling Zug.UI.Gtk.Anschluss
        [26 of 40] Compiling Zug.UI.Gtk.ZugtypSpezifisch
        [27 of 40] Compiling Zug.UI.Save
        [28 of 40] Compiling Zug.UI.Befehl
        [29 of 40] Compiling Zug.UI.StatusVar
        [30 of 40] Compiling Zug.UI.Gtk.StreckenObjekt
        [31 of 40] Compiling Zug.UI.Gtk.Assistant
        [32 of 40] Compiling Zug.Warteschlange
        [33 of 40] Compiling Zug.UI.Gtk.Fenster.AssistantHinzufuegen
        [34 of 40] Compiling Zug.UI.Gtk.Fenster
        [35 of 40] Compiling Zug.UI.Gtk
        [36 of 40] Compiling Zug.UI.Cmd.Parser.Plan
        [37 of 40] Compiling Zug.UI.Cmd.Parser.StreckenObjekt
        [38 of 40] Compiling Zug.UI.Cmd.Parser
        [39 of 40] Compiling Zug.UI.Cmd
        [40 of 40] Compiling Zug.UI

Erlaube "Warten auf Signal"
    Ergänze "Warten"-Funktion von Plänen auf ein Signal (Pin-Input = HIGH/LOW) zu warten.
        GUI-Darstellung:
            leerer/roter Kreis
            wird grün, wenn Signal triggert
    Zeit-basierte Lösung wird weiterhin unterstützt.
    Mögliche Realisierung über Kontaktschienen (Ground-Kontakt durch Zug verbunden).

Implementiere Server/Client-Modus:
    Raspi läuft im Server-Modus und reagiert auf eingehende Nachrichten (evtl. nur von fester IP-Adresse)
        stdout-Ausgabe der eigene IP-Adresse bei Start
    Client sendet Nachrichten an angegebene TCP-Adresse
    Zusätzliche Kommandozeilenoption:
        --ip
            Gibt die eigene IP-Adresse aus und beendet sich
    Benötigte Packages:
        network-info
            eigene IP-Adresse
        network-simple
            TCP-Nachrichten mit einfachem API

Code-Stil vereinheitlichen:
    hlint berücksichtigen(?)
    Konstruktoren nur wenn notwendig in Klammern setzten
    Argumente von Typkonstruktoren eingerückt, jeweils in neuer Zeile
    Funktionen ohne Pattern match (nur ein Variablen-Pattern) ohne extra Leerzeichen
    Alle (auch eigene) Module mit Import-Liste
    Namen auf Deutsch
    Verwendung der Spracherweiterungen
        ScopedTypeVariables
            explizites `forall a.` in Deklaration bindet a als festen Typ für die gesamte Funktion (auch let/where-Deklarationen)
            erlaubt vorher teilweise unmögliche Typ-Deklarationen (z.B. res :: a in einem where-Binding als Rückgabewert der Funktion verwendbar)
        OverlappableInstances
            {-# Overlappable #-}/{-# Overlapping #-} bei Instanz-Deklaration
            allgemeinen Fall abdeckbar, ohne Spezial-Instanzen zu verhindern
            Benötigt Spracherweiterungen FlexibleInstances, UndecidableInstances, MonoLocalBinds (?)
            Done
    floskell.json verbessern
        aktuelle Version sollte für alle Dateien angewendet sein
        formatOnSave ist ebenfalls aktiviert
    etc.

CPP im Code entfernen
    Durch Plugin-System ersetzen
        Cmd-UI immer vorhanden
        Bei Programmstart durchsuchen des Ordners "./UI/"
            Für jede vorhandene Datei biete es als Option für UI an
            Erwarte eine main :: IO ()-Funktion, welche bei Auswahl aufgerufen wird.
        https://hackage.haskell.org/package/plugins
        https://hackage.haskell.org/package/dynamic-loader
    Verschiedene Executables (in package.yaml) macht mehr Sinn

Allgemeines Anschluss-Objekt mit allen möglichen Funktionen erstellen?
    Strom an/aus
        permanent
        auf Zeit
    PWM
    Signal erkennen
        wenn implementiert

gi-gtk/gi-gtk-declarative verwenden?
    gi-gtk scheint neuer und besser gewartet zu sein.
    Wirft auf Raspberry Pi bisher Fehlermeldungen.
        Warten bis eine neue GHC-Version auf Raspi funktioniert?
            8.6.3 benötigt besondere Behandlung: https://svejcar.dev/posts/2019/09/23/haskell-on-raspberry-pi-4/
            funktioniert auf Windows nicht!

Beispiel-Schaltpläne erstellen
    Beispiel-Schaltpläne zum Anschluss der Schiene an den Raspberry Pi erstellen.
    In der ReadMe erwähnen/verlinken.

Hilfetext von optparse-applicative übersetzten
    Eigene helper-Funktion erstellen.
    Außerdem sämtliche Hilfetexte in Language.hs auslagern.

Test-Suite erstellen?
    Muss gepflegt werden um Sinn zu machen.
    Nachdem das de-facto ein persönliches Projekt ist vermutlich den Aufwand nicht Wert.

---------------------------Gelöst--------------------------
Einträge erscheinen öfters in yaml-Datei
    vermutlich von Laden -> Speichern
    Abbrechen beim Hinzufügen?
    Gefixt

Pläne mit Dauerschleife werden nicht ausgeführt
    Eq-Instanz versucht unendlich lange Listen zu vergleichen
    Gefixt

Jedem Plan eine eigene ProgressBar spendieren.
    Aktuell kommt es zu RaceConditions in der Anzeige wenn mehrere gleichzeitig ausgeführt werden.
        Done
    Außerdem muss überprüft werden, warum ProgressBar (vertikal) so klein sind.

Anzeige sprachabhängig, ohne Show-Instanz
    über eigene Anzeige-Klasse
        Done
    speichern der aktuellen Sprache im Zustand
        Kommandozeilen-Argument bezieht sich nur noch auf Anfangs-Sprache
            Speichern in .json?
            Wird nicht gespeichert
        Sprachwechsel im Cmd-UI kein Problem:
            wird sowieso neu erzeugt
            muss noch implementiert werden
                Done
        GTK-Objekte müssen bei Sprachwechsel neu benannt werden
            ergänze (SP ObjektGui) im Zustand um [Sprache -> IO ()]
                werden bei Sprachwechsel alle via sequence_ aufgerufen
                wie wird die IO-Funktion wieder gelöscht?
                    ToDo!!!
                    Widgets werden nicht gelöscht -> IO-Aktion muss auch nicht gelöscht werden
                    führt evtl. zu Memory-Leaks, wenn das Programm zu lange läuft
                Mit Objekt als Widget taggen? [(Gtk.Widget, Sprache -> IO ())]
                    Map/HashMap wegen fehlender Ord/Hashable-Instanz nicht möglich
                Speichere (Maybe [Sprache -> IO ()]) in TVar, welche bei löschen auf Nothing gesetzt wird
                    Übergebe Maybe (TVar (Maybe [Sprache -> IO ()])) an verwendeSpracheGui
                    Wenn Nothing, speichere weiterhin global
                    Wenn TVar, schaue Inhalt an
                        Wenn Nothing füge ausführen aller TVar-Aktionen zur globalen Liste hinzu
                            und ersetzte TVar-Inhalt durch Just [übergebeneAktion]
                        Wenn (Just ..) füge nur die übergebene Aktion zur TVar hinzu
                Speichere Aktionen in SpracheGui als [Either (Sprache -> IO ()) (TVar (Maybe [Sprache -> IO ()]))]
                    Wenn bei Aufruf (via foldM) TVar mit Nothing entdeckt wird, lösche diesen Eintrag
                    Ist ein widgetDestroy notwendig?
                Führe außerdem widgetDestroy beim entfernen aus
                    jeweils äußerstes Widget (welches bisher nur aus Container entfernt wird) sollte ausreichen
            Sprachwechsel über AuswahlWidget (ComboBox)
                Done

Speichern von json in yaml konvertieren
    Packet yaml zur Konvertierung verwenden
        https://hackage.haskell.org/package/yaml
    Verwendet intern aeson, kann somit problemlos als plug-and-play replacement verwendet werden
        Done

Gtk.StreckenObjekt.hs
    ..PackNew auf MStatusGuiT umstellen
    TMVar wird dadurch nicht mehr benötigt
        es kann 'ausführenTMVarBefehl' in 'buttonLadenPack' verwendet werden
    Done

Cmd-UI:
    *Unbekannt aus Datentypen entfernen und eigenen (ParseErgebnis a)-Datentyp verwenden
        *Unbekannt hat überall identische Struktur
    Analog zu Either als Fehler-Monade
        Monade geht nicht, wegen Either-Ähnlicher Typvariable (keine anderen Typen erlaubt)
        -> eigene Verkettung-Funktion erstellen
            Done
    wähleBefehl oft mit AFFehler als Ausweich-Lösung und AFZwischenwert für jedes Ergebnis
        -> eigenen Befehl wähleFortsetzung erstellen
            Done
    Jede Auswertung von AnfrageFortsetzung hat vorherigen Zustand
        -> muss im Fehlerfall nicht gespeichert werden
            Done
    Done

Rekursion in Plan ermöglichen
    erlaubt Divide-And-Conquer beim aufbauen größerer Pläne
    potentielle Endlosschleifen
        problematisch?
        nein, da 'ausführenAbbrechen' immer möglich
        bei Anzeigen/Eq-Vergleich auf Wiederholungen prüfen!
            kann mit UI nicht erzeugt werden
            Speichern in .json ebenfalls nicht möglich
            verwende nur Name bei Plänen
                vermeidet rekursive Aufrufe
                speichern Problematisch, wenn Plan schon gelöscht
                erfordert durchsuchen anderer Pläne beim Laden
                    Parse-Reihenfolge wichtig?
        Schleife-Aktion um Dauerschleife problemlos zu ermöglichen
            Probleme bei ausführenAktion/ausführenPlan
        eigenes Feld in Plan für Dauerschleife
            endliche Wiederholungen möglich mit 2 Plänen
            dadurch kein Integer-Feld notwendig
    Done

Zugtyp-Mischformen von Wegstrecken
    Mischformen können aktuell zu potentiell unerwartetem Verhalten führen:
        Wenn als Märklin interpretiert: alle Lego-Bahngeschwindigkeiten werden auf Vorwärts gestellt
        Wenn als Lego interpretiert: alle Märklin-Bahngeschwindigkeiten drehen um
    Mögliche Lösungen:
        Smart-Constructor für Wegstrecken um (wenn nötig) einen eindeutigen Zugtyp sicherzustellen?
        wegstrecke :: Text -> [Bahngeschwindigkeit] -> [Streckenabschnitt] -> [(Weiche, Richtung)] -> [Kupplung] -> Maybe Wegstrecke
            stelle smart-Destructor zum Pattern Matching bereit
            Selector-Funktionen exportieren?
            PatternSynonyms verwenden?
                https://haskell-explained.gitlab.io/blog/posts/2019/08/27/pattern-synonyms/index.html
        Identischer View-Datentyp mit exportiertem Konstruktor?
        Alternativ Umdrehen bei unklarem Zugtyp der verwendeten Bahngeschwindigkeiten verbieten?
    Gelöst über Zugtyp-Phantomtyp (DataKinds)

PCF8574Port als alternative zu Pin erlauben
    Summentyp Anschluss
    definiert in PCF8574.hs?
    eigenes Modul verwenden (Anschluss.hs) für einfache Erweiterung?
        Done
MVar durch TVar ersetzen
    sollen sowieso immer gefüllt sein
        Done

VRCheckbutton durch abstrakten Datentyp RegistrierterCheckButton ersetzen
    FortfahrenWennToggled mit MVar ersetzten durch abstrakten Datentyp, welcher registrieren beim erstellen ausführt (... -> IO RegistrierterCheckbutton)?
        LinkedMVar benötigt dadurch Update-Aktion nicht mehr
        Konstruktor muss LinkedMVar kennen
    LinkeMVar entfernen?
        Done

Widget.hs: eigenen bool-like Datentyp für Position erstellen
    data Position = First | Last
    newtype für Padding
        Done

GTK-UI: Gleichzeitiges Anzeigen mehrerer Kategorien ermöglichen
    optional?
    VPaned/HPaned verwenden